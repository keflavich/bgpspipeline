;----------------------------------------------------------------------------
;
; NAME: calc_beam_locations.pro
;
; PURPOSE: Uses the data generated by all of the full array
;          beam map observations taken during the run to 
;          compute the average position of each beam on the
;          sky (i.e. after propagating it through the optical
;          system).  This emperical approach has been employed
;          since the optical system cannot be fit well by
;          the Seidel, Zernike, or any other polynomial
;          expansion.  The data file output by this program
;          is intended to be read in by find_pixel_offsets.pro.
;
; LIMITATIONS: Currently, this program is only set up to calculate
;          beam locations for data taken with the dewar NOT ROTATING.
;          If the dewar was rotated this program may not produce 
;          good results (due to the assymetry in the optical system). 
;
; INPUTS:  file_arg: Any one of the following possibilities,
;                1) string array of wildcards for the .ctr files
;                2) filelist of .ctr files
;                3) string array of filenames for the .ctr files
;                4) 2xN int array of date and obsnum [[yymmdd, ooo],[.],..]
;
; KEYWORDS: input_folder_root: The path to the .ctr files, currently
;               it is '~/data/200310/centroid'.  Note that the trailing 
;               slash is omitted.
;           params_folder_root: The path to the _array_params files.
;           input_file_root: The complete root of the .ctr file, currently
;               it is 'yymmdd_ooo_clean_ptg_map'.  Note that the trailing
;               period is omitted, and yymmdd, and ooo must be entered
;               in that exact way.
;           params_file_root: The complete root of the _array_params
;               files.  Note that these are the files from
;               calc_ptg_resid, NOT the individual array parameters
;               files, confusing I know.  Also remember to put the
;               exact string 'yymmdd_ooo' at the beginning.
;           input_file_extension: The extension of the .ctr files, currently
;               it is 'ctr'.  Note that the leading period is omitted.
;           params_file_extension: The extension of the _array_params
;               files, again, the one from calc_ptg_resid, not the
;               individual array parameters files.
;           bolo_params_file: The filename of the bolo_params file
;               for the observing run.
;           out_file: The filename to print the summary statistics to.
;           good_bolos: A 1-dimensional int array of the good bolometer numbers
;           bad_bolos: A 1-dimensional int array of the bad bolometer numbers
;           diagnostic_flag: set this flag to have diagnostic information
;               printed to the screen.
;           tolerance: The number of standard deviations from the mean where
;               the data should be cut at (i.e. removal of the outliers).  I
;               have found that 2.5 is a good value - BUT JUDGE FOR YOURSELF
;               BASED ON THE DIAGNOSTIC OUTPUT!!
;           cut_iterations: An iterative cutter is employed to eliminate
;               the outliers - this sets the maximum number of times
;               the cutter loop will run.
;	    sigmacut: Do an iterative datadiscard cut on each bolometer.  Set 
;		to anything other than 1 will produce a n-sigma cut threshold
;           global_array_params_file: This keyword should be set if the dewar
;               was not rotated during the run.  Set it equal to the array_params
;               file (i.e. cleaning/parameters/array_params_nov04.txt)
;
; AUTHOR: Jack Sayers (2004/02/17)
;
; REVISION HISTORY:
; 	040408 GL - Edited to allow for partial beam maps to be included (sigmacut)
;	040409 GL - Minor bug fix
;       040727 JS - made the program more user friendly by changing default
;                   keyword values
;       060910 DJH - Allowed for rotator moving slipping.  Unlikely to
;                    ever need this and certainly don't trust the
;                    results blindly.
;----------------------------------------------------------------------------

pro op_cbl, $
    file_arg, $
    input_folder_root = input_folder_root, $
    input_file_root = input_file_root, $
    input_file_extension = input_file_extension, $
    params_folder_root = params_folder_root, $
    params_file_root = params_file_root, $
    params_file_extension = params_file_extension, $
    bolo_params_file = bolo_params_file, $
    out_file = out_file, $
    good_bolos = good_bolos, $
    bad_bolos = bad_bolos, $
    diagnostic_flag = diagnostic_flag, $
    tolerance = tolerance, $
    cut_iterations = cut_iterations,$
    sigmacut=sigmacut, $
    global_array_params_file = global_array_params_file, $
    ncfile = ncfile


;---------------------------------------------------------------------------
;
; First set all the keywords to default values in case they were
; not input by the user.
;
;---------------------------------------------------------------------------

if(size(file_arg, /type) ne 7) then begin
  if not keyword_set(input_file_root) or $
     not keyword_set(input_folder_root) then $
       message, 'If the list of files is input as an array of integer ' + $ 
                'yymmdd and obs then the input_file_root and input_' + $
                'folder_root keywords must be set.'
endif else begin
  temp_file = (file_search(file_arg[0]))[0]
  if temp_file ne '' then begin
    if not keyword_set(input_folder_root) then begin
      index = strpos(temp_file, 'centroid')
      input_folder_root = strmid(temp_file, 0, index + strlen('centroid'))
    endif
    if not keyword_set(input_file_root) then begin
      index = strpos(temp_file, '/', /reverse_search)
      input_file_root = 'yymmdd_ooo' + strmid(temp_file, index+11)
      index = strpos(input_file_root, '.', /reverse_search)
      input_file_root = strmid(input_file_root, 0, index)
    endif
  endif
endelse

if not keyword_set(params_folder_root) then $
  params_folder_root = input_folder_root
if not keyword_set(params_file_root) then $
  params_file_root = input_file_root + '_array_params'
if not keyword_set(input_file_extension) then $
         input_file_extension = 'ctr'
if not keyword_set(params_file_extension) then $
         params_file_extension = 'txt'
if not keyword_set(out_file) then $
         out_file = '~/beam_locations.txt'
if not keyword_set(bolo_params_file) then $
         bolo_params_file = '~/bolocam_cvs/pipeline' + $
                            '/cleaning/parameters/bolo_params_oct03.txt'
if not keyword_set(tolerance) then $
         tolerance = 3
if not keyword_set(cut_iterations) then $
         cut_iterations = 10

common USER_COMMON
common BOLO_COMMON
input_type_flag = 1

;---------------------------------------------------------------------------
;
; Next, we need to make sure all the input/output files exist/can be written.
; Then read in the data.
;
;----------------------------------------------------------------------------

;error check on inputs
if n_params() lt 1 then message, 'Requires at least 1 calling parameter.'

;if file_arg is not a string, but a 2xN array of yymmdd and obs_num
;then we need to generate a filelist with the filenames
if(size(file_arg, /type) ne 7) then begin
  input_type_flag = 0
  date = strarr(n_elements(file_arg)/2)
  obs_num = strarr(n_elements(file_arg)/2)
  temp_file_arg = strarr(n_elements(file_arg)/2)

  ;get rid of all the decimal points  
  file_arg = long(file_arg)
  for i=0, n_elements(file_arg)/2 -1 do begin
    ;create the correct date
    if (file_arg[0,i] lt 100000) then begin
      date[i] = '0' + strtrim(string(file_arg[0,i]), 1)
    endif else begin
      date[i] = strtrim(string(file_arg[0,i]), 1)   
    endelse

    ;thanks to the naming structure (ob2, o22, 222) 
    ;for the obs number the following lines are needed
    if (file_arg[1,i] lt 10) then begin
      obs_num[i] = 'ob' + strtrim(string(file_arg[1,i]), 1)
    endif else begin
      if (file_arg[1,i] lt 100) then begin
        obs_num[i] = 'o' + strtrim(string(file_arg[1,i]), 1)
      endif else begin
        obs_num[i] = strtrim(string(file_arg[1,i]), 1)
      endelse
    endelse

    ;check to see if the date and obs_num have the correct number of digits
    if (strlen(date[i]) ne 6) then begin
      message, 'The date of element ' + strtrim(string(i),1) + $ 
               ' in your input array  = ' + date[i] + '.  ' + $
               'This is not the correct length/format.'
    endif 
    if (strlen(obs_num[i]) ne 3) then begin
      message, 'The obs_num of element ' + strtrim(string(i),1) + $
               ' in your input array = ' + obs_num[i] + '.  ' + $
               'This is not the correct length/format.'
    endif

    ;now add the filename to the filelist
    temp = input_folder_root + '/*/' $
          + input_file_root + '.' + input_file_extension
    strput, temp, date[i], strpos(temp, 'yymmdd')
    strput, temp, obs_num[i], strpos(temp, 'ooo')
    temp1 = file_search(temp)
    temp_file_arg[i] = temp1
    if (temp_file_arg[i] eq '') then begin
      message, 'Cannot find the .ctr file for: ' + $
               'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
               ', (element ' + strtrim(string(i),1) + ' in your input array).'
    endif
    if (n_elements(temp1) gt 1) then begin
      message, 'More than one .ctr file exists for: ' + $
               'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
               ', (element ' + strtrim(string(i),1) + ' in your input array).'
    endif
  endfor
  file_arg = temp_file_arg
endif

;program will crash if file_arg has a null argument, this fixes the problem
non_zero_index = where(file_arg ne '')
file_arg = file_arg[non_zero_index]

;now use process_file_arg to clean up the file list, or to generate
;the list if a wildcard was input
file_arg = process_file_arg(file_arg, input_file_extension, status = status)
if (file_arg[0] eq '' or status ne 1) then begin
  message, /cont, 'process_file_arg returns empty file list or error status'
  message, /cont, 'input file_arg = ' + file_arg[i]
endif
n_files = n_elements(file_arg)
if keyword_set(diagnostic_flag) then begin
  print, ''
  print, 'READING IN DATA FROM:'
  print, file_arg
  print, ''
endif

;if file_arg was input as a filelist then we need to generate the strarr's
;date and obsnum to get the params file associated with the ob
if(input_type_flag) then begin
  date = strarr(n_files)
  obs_num = strarr(n_files)

  for i=0L, n_files-1 do begin
    temp_index = strpos(file_arg[i], IDL_FILESEP, /reverse_search)
    temp_filename = strmid(file_arg[i], temp_index+1)
    temp_index = str_index(temp_filename, '_')
    date[i] = strmid(temp_filename, 0, temp_index)
    obs_num[i] = strmid(temp_filename, temp_index+1, $
                 3)
  endfor
endif

;now generate the list of params files associated with each 
;observation
params_arg = strarr(n_files)
temp_params_arg = strarr(n_files)
cleaned_arg = strarr(n_files)
temp_cleaned_arg = strarr(n_files)
for i=0L, n_files-1 do begin
  temp = params_folder_root + '/*/' $
       + params_file_root + '.' + params_file_extension
  strput, temp, date[i], strpos(temp, 'yymmdd')
  strput, temp, obs_num[i], strpos(temp, 'ooo')
  temp1 = file_search(temp)
  temp_params_arg[i] = temp1
  if (temp_params_arg[i] eq '') then begin
    message, 'Cannot find the params file for: ' + $
             'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
             ', (element ' + strtrim(string(i),1) + ' in your input array).'
  endif
  if (n_elements(temp1) gt 1) then begin
      message, 'More than one params file exists for: ' + $
        'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
        ', (element ' + strtrim(string(i),1) + ' in your input array).'
  endif
  ; Do the same to find the cleaned file
;  temp = cleaned_folder_root + '/*/' $
;       + cleaned_file_root + '.' + cleaned_file_extension
;  strput, temp, date[i], strpos(temp, 'yymmdd')
;  strput, temp, obs_num[i], strpos(temp, 'ooo')
;  temp1 = file_search(temp)
;  temp_cleaned_arg[i] = temp1
;  if (temp_cleaned_arg[i] eq '') then begin
;    message, 'Cannot find the cleaned file for: ' + $
;             'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
;             ', (element ' + strtrim(string(i),1) + ' in your input array).'
;  endif
;  if (n_elements(temp1) gt 1) then begin
;    message, 'More than one cleaned file exists for: ' + $
;             'date = ' + date[i] + ', obs_num = ' + obs_num[i] + $
;             ', (element ' + strtrim(string(i),1) + ' in your input array).'
;  endif
endfor
params_arg = temp_params_arg
;cleaned_arg = temp_cleaned_arg

;now use process_file_arg to make sure that bolo_params_file exits
bolo_params_file = process_file_arg(bolo_params_file, '.txt', status = status)
if(n_elements(bolo_params_file) gt 1) then begin
  message, 'more than one bolo_params_file was found.'
endif
if (bolo_params_file eq '' or status ne 1) then begin
  message, 'process_file_arg returns empty file list or error status'
  message, 'input bolo_params_file = ' + bolo_params_file
endif

;if good_bolos is not set, then use the first .ctr file to 
;generate the list of good bolometers.
if not keyword_set(good_bolos) then begin
  bolo_mask = bytarr(144)
  for i=0L, n_files-1 do begin
    temp = read_ascii(file_arg[i], comment = ';')
    temp = temp.field1
    bolo_mask[temp[0,*]] = 1
  endfor
  good_bolos = where(bolo_mask eq 1)
endif
if(n_elements(good_bolos) ne n_elements(uniq(good_bolos))) then $
  message, 'Your list of good bolometers has a non-unique element ' + $
           '- i.e. a repeated bolometer number.'

;remove all the bad bolos
if keyword_set(bad_bolos) then begin
  for i=0, n_elements(bad_bolos)-1 do begin
    index = where(good_bolos ne bad_bolos[i])
    good_bolos = good_bolos[index]
  endfor
endif

n_bolos = n_elements(good_bolos)

;now create an array of structs to hold the data
data = replicate(create_struct( $
         'bolo_num', good_bolos, $
         'mask', intarr(n_bolos) + 1, $
         'bolo_DCoffset', fltarr(n_bolos), $
         'bolo_peak_volt', fltarr(n_bolos), $
         'beam_stddev_x', fltarr(n_bolos), $
         'beam_stddev_y', fltarr(n_bolos), $
         'beam_offset_x', fltarr(n_bolos), $
         'beam_offset_y', fltarr(n_bolos), $
         'beam_position_angle', fltarr(n_bolos), $
         'beam_corrected_offset_x', fltarr(n_bolos), $
         'beam_corrected_offset_y', fltarr(n_bolos), $
         'plate_scale', 0., $
         'mean_FWHM', 0., $
         'array_rot_angle', 0., $
         'array_offset_x', 0., $
         'array_offset_y', 0.), $
       n_files)

;extract the data from the files and store it in the struct
for i=0L, n_files-1 do begin
  temp = read_ascii(file_arg[i], comment = ';')
  temp = temp.field1
  temp_n_bolos = n_elements(temp[0,*])
 
  ;error check the data that has been read in
  if(n_elements(temp[*,0]) ne 8) then begin
    message, 'The data in ' + file_arg[i] + $
             ' does not have the correct number of columns.'
  endif

  if keyword_set(diagnostic_flag) then begin
    if(temp_n_bolos ne n_bolos) then begin
      print, 'The data in "' + file_arg[i] + '" has ' + $
             strtrim(string(fix(temp_n_bolos)),1) + ' bolometers ' + $
               'instead of the expected ' + strtrim(string(fix(n_bolos)),1)
    endif
  endif    

  ;if the data is good then read it in to the struct
  for j=0, n_bolos-1 do begin
    index = where(temp[0,*] eq good_bolos[j])
    if(index[0] eq -1) then begin
      data[i].mask[j] = 0
    endif else begin
      data[i].bolo_DCoffset[j] = temp[1,index]
      data[i].bolo_peak_volt[j] = temp[2,index]
      data[i].beam_stddev_x[j] = temp[3,index]
      data[i].beam_stddev_y[j] = temp[4,index]
      data[i].beam_offset_x[j] = temp[5,index]
      data[i].beam_offset_y[j] = temp[6,index]
      data[i].beam_position_angle[j] = temp[7,index]
    endelse
  endfor

  ;now read in the data from the params file
  temp = read_ascii(params_arg[i], comment = ';', delimiter = '=')
  temp = reform(temp.field1[1,*])
  if(n_elements(temp) ne 6) then begin
      message, 'the data in ' + params_arg[i] + $
        ' is not the correct format.'
  endif

;  fileid = ncdf_open(temp_cleaned_arg[i])
  fileid = ncdf_open(ncfile[i])
  ncdf_varget_scale,fileid,'rotangle',rotangle
  rotangle = median(rotangle)
  If (rotangle eq 0.) then begin
      message,/cont,'Rotator Angle is 0.0, no correction will be made for this observation'
  endif else begin
      range = max(rotangle[where(rotangle lt 65.)]) - min(rotangle[where(rotangle gt -65.)])
      if (abs(range) gt 3.) then begin
          message,'Rotation is too big to produce a reliable estimate for the beam locations',/cont
          message,infilearr[ifile],/cont
          message,'Stopping ...'
      endif
      message,/cont,'Encoder angle is not zero for this observation and will be taken account of.'
  endelse
  ncdf_close,fileid

  ;store the data read in from the params file
  data[i].plate_scale = temp[0]
  data[i].mean_FWHM = temp[1]
  data[i].array_rot_angle = temp[2]
  data[i].array_offset_x = temp[3]
  data[i].array_offset_y = temp[4]
  
  ;read in the plate scale and rot angle from the global array_params
  ;file if the dewar was not rotated
  if keyword_set(global_array_params_file) then begin
    readcol, global_array_params_file, temp, format = '(X,F)', /silent
    data[i].plate_scale = temp[0] * 25.4 / 5.
    data[i].array_rot_angle = temp[2]
  endif

endfor

;read in the data from the bolo_params file
bolo_offset_x = fltarr(n_bolos)
bolo_offset_y = fltarr(n_bolos)
temp = read_ascii(bolo_params_file, comment = ';')
temp = temp.field1
if(n_elements(temp[*,0]) ne 4) then begin
  message, 'bolo_params_file = ' + bolo_params_file + $
           ' is not the correct format.'
endif

;read in the data from the bolo_params_file.  This is tricky
;because the bolometers are listed as 'BOLO_B12', instead of
;as 35.  This program assumes that the bolometers are listed in 
;the correct order.  
;Also, we need to convert polar coordinates to cartesian.
for i=0, n_bolos-1 do begin
  bolo_offset_x[i] = cos(!dtor * temp[2, good_bolos[i]]) * $
                         temp[3, good_bolos[i]]
  bolo_offset_y[i] = sin(!dtor * temp[2, good_bolos[i]]) * $
                         temp[3, good_bolos[i]]
endfor

;-----------------------------------------------------------------------
;
; Now we finally have all the data we need stored in the data struct.
; At this point we need to convert the data to be relative the 
; fiducial, so that we can compare the data from different obs.
;
;-----------------------------------------------------------------------

for i=0L, n_files-1 do begin

  ;first, shift the beam offsets to correct for the offset of 
  ;the center of the array
  data[i].beam_corrected_offset_x = $
          data[i].beam_offset_x - data[i].array_offset_x
  data[i].beam_corrected_offset_y = $
          data[i].beam_offset_y - data[i].array_offset_y

  ;now correct for the rotation angle of the array
  temp_x = fltarr(n_bolos)
  temp_y = fltarr(n_bolos)
  temp_x = $
          cos(!dtor * data[i].array_rot_angle) * $
          data[i].beam_corrected_offset_x + $
          sin(!dtor * data[i].array_rot_angle) * $
          data[i].beam_corrected_offset_y
  temp_y = $
          cos(!dtor * data[i].array_rot_angle) * $
          data[i].beam_corrected_offset_y - $
          sin(!dtor * data[i].array_rot_angle) * $
          data[i].beam_corrected_offset_x
  data[i].beam_corrected_offset_x = temp_x
  data[i].beam_corrected_offset_y = temp_y

  ;now correct for the plate scale, the offsets will now
  ;be in bolometer spacing units instead of arsec
  data[i].beam_corrected_offset_x = $
          data[i].beam_corrected_offset_x / data[i].plate_scale
  data[i].beam_corrected_offset_y = $
          data[i].beam_corrected_offset_y / data[i].plate_scale

endfor

;initialize some arrays, then store the statistics on the 
;beam locations
median_x = fltarr(n_bolos)
stddev_x = fltarr(n_bolos)
median_y = fltarr(n_bolos)
stddev_y = fltarr(n_bolos)

for i=0, n_bolos-1 do begin
  valid_index = where(data.mask[i] eq 1,nvalid_index)
  if nvalid_index eq 0 then message,'ERROR: bolometer '+strtrim(good_bolos(i),2)+' has no valid centroids'
  median_x[i] = median([data[valid_index].beam_corrected_offset_x[i]])
  median_y[i] = median([data[valid_index].beam_corrected_offset_y[i]])
  stddev_x[i] = sqrt(total((data[valid_index].beam_corrected_offset_x[i] - $
                            median_x[i])^2 / (n_elements(valid_index)-1)))
  stddev_y[i] = sqrt(total((data[valid_index].beam_corrected_offset_y[i] - $
                            median_y[i])^2 / (n_elements(valid_index)-1)))
endfor

;--------------------------------------------------------------------------
;
; Now that the data is relative to the fiducial we can compute
; statistics on the beam positions, and use these statistics to
; cut any "outliers".
;
;-------------------------------------------------------------------------- 

;040408 GL While JS's method has its advantages, using multiple files requires a more strict cut
if keyword_set(sigmacut) then begin
	if sigmacut ne 1 then sigma=sigmacut
	for i_bolo=0L,n_bolos-1L do begin
		valid_obs=where(data.mask[i_bolo] eq 1,nvalid_obs)
		x_data=data[valid_obs].beam_corrected_offset_x[i_bolo]
		y_data=data[valid_obs].beam_corrected_offset_y[i_bolo]
		goodflag=datadiscard_multi(transpose([[x_data],[y_data]]),sigma=sigma,bounds=transpose([[-7,7],[-7,7]]))					
		valid_bad=where(goodflag eq 0,nvalid_bad)
		if nvalid_bad gt 0 then data[valid_obs[valid_bad]].mask[i_bolo]=0		
	endfor
endif else begin

;now throw out any outliers - the tolerance is the deviation
;in sigma from the mean (of the stddev's in the individual beam positions)
;where the cut will happen.
median_stddev_x = median(stddev_x)
median_stddev_y = median(stddev_y)
stddev_stddev_x = sqrt(total((stddev_x - median_stddev_x)^2 / (n_bolos-1)))
stddev_stddev_y = sqrt(total((stddev_y - median_stddev_y)^2 / (n_bolos-1)))

;this is an iterative cutter - it removes the bad data, recomputes
;the standard deviation, then cuts again until all points
;outside the set tolerance have been cut
finished = 0
counter = 0
while(finished eq 0 and counter lt cut_iterations) do begin
  finished = 1
  counter = counter + 1

  for i=0, n_bolos-1 do begin 
    relative_scatter_x = abs(stddev_x[i] - median_stddev_x) / $
                         (tolerance * stddev_stddev_x)
    relative_scatter_y = abs(stddev_y[i] - median_stddev_y) / $
                         (tolerance * stddev_stddev_y)

    if(relative_scatter_x gt 1) then begin
      valid_index = where(data.mask[i] eq 1)
      if keyword_set(diagnostic_flag) then begin
        print, ''
        print, 'Before the iterative cut bolometer ' + $
               strtrim(string(fix(good_bolos[i])),1) + $
               ' had the following valid x-offset(s):
        print, data[valid_index].beam_corrected_offset_x[i]  
      endif

      good_data = where(abs(data[valid_index].beam_corrected_offset_x[i] $
                            - median_x[i]) lt $
                            (tolerance/relative_scatter_x * stddev_x[i]))
      if(n_elements(good_data) eq n_elements(valid_index)) then begin
        if keyword_set(diagnostic_flag) then begin
          print, 'After the iterative cut bolometer ' + $
                 strtrim(string(fix(good_bolos[i])),1) + $
                 ' had the following valid x-offset(s):
          print, data[valid_index].beam_corrected_offset_x[i]  
        endif
      endif else begin
        finished = 0
        if(good_data[0] eq -1) then begin
          if keyword_set(diagnostic_flag) then begin  
            print, 'After the iterative cut bolometer ' + $
                   strtrim(string(fix(good_bolos[i])),1) + $
                   ' has 0 valid x-offsets.'
          endif
          median_x[i] = 0.
          median_y[i] = 0.
          stddev_x[i] = 0.
          stddev_y[i] = 0.
          data.mask[i] = 0

        endif else begin
          valid_index = valid_index[good_data]
          data.mask[i] = 0
          data[valid_index].mask[i] = 1
          if keyword_set(diagnostic_flag) then begin
            print, 'After the iterative cut bolometer ' + $
                   strtrim(string(fix(good_bolos[i])),1) + $
                   ' had the following valid x-offset(s):'
            print, data[valid_index].beam_corrected_offset_x[i]  
          endif

          if(n_elements(good_data) eq 1) then begin
            median_x[i] = data[valid_index].beam_corrected_offset_x[i]
            median_y[i] = data[valid_index].beam_corrected_offset_y[i]
            stddev_x[i] = 0.
            stddev_y[i] = 0.
          endif else begin
            median_x[i] = median(data[valid_index].beam_corrected_offset_x[i])
            median_y[i] = median(data[valid_index].beam_corrected_offset_y[i])
            stddev_x[i] = $
                sqrt(total((data[valid_index].beam_corrected_offset_x[i] - $
                            median_x[i])^2 / (n_elements(valid_index)-1)))
            stddev_y[i] = $
                sqrt(total((data[valid_index].beam_corrected_offset_y[i] - $
                            median_y[i])^2 / (n_elements(valid_index)-1)))
            endelse
        endelse
      endelse
    endif

    if(relative_scatter_y gt 1) then begin
      valid_index = where(data.mask[i] eq 1)
      if keyword_set(diagnostic_flag) then begin
        print, ''
        print, 'Before the iterative cut bolometer ' + $
               strtrim(string(fix(good_bolos[i])),1) + $
               ' had the following valid y-offset(s):
        print, data[valid_index].beam_corrected_offset_y[i]  
      endif

      good_data = where(abs(data[valid_index].beam_corrected_offset_y[i] $
                            - median_y[i]) lt $
                            (tolerance/relative_scatter_y * stddev_y[i]))
      if(n_elements(good_data) eq n_elements(valid_index)) then begin
        if keyword_set(diagnostic_flag) then begin
          print, 'After the iterative cut bolometer ' + $
                 strtrim(string(fix(good_bolos[i])),1) + $
                 ' had the following valid y-offset(s):
          print, data[valid_index].beam_corrected_offset_y[i]  
        endif
      endif else begin
        finished = 0
        if(good_data[0] eq -1) then begin
          if keyword_set(diagnostic_flag) then begin  
            print, 'After the iterative cut bolometer ' + $
                   strtrim(string(fix(good_bolos[i])),1) + $
                   ' has 0 valid y-offsets.'
          endif
          median_x[i] = 0.
          median_y[i] = 0.
          stddev_x[i] = 0.
          stddev_y[i] = 0.
          data.mask[i] = 0

        endif else begin
          valid_index = valid_index[good_data]
          data.mask[i] = 0
          data[valid_index].mask[i] = 1
          if keyword_set(diagnostic_flag) then begin
            print, 'After the iterative cut bolometer ' + $
                   strtrim(string(fix(good_bolos[i])),1) + $
                   ' had the following valid y-offset(s):'
            print, data[valid_index].beam_corrected_offset_y[i]  
          endif

          if(n_elements(good_data) eq 1) then begin
            median_x[i] = data[valid_index].beam_corrected_offset_x[i]
            median_y[i] = data[valid_index].beam_corrected_offset_y[i]
            stddev_x[i] = 0.
            stddev_y[i] = 0.
          endif else begin
            median_x[i] = median(data[valid_index].beam_corrected_offset_x[i])
            median_y[i] = median(data[valid_index].beam_corrected_offset_y[i])
            stddev_x[i] = $
               sqrt(total((data[valid_index].beam_corrected_offset_x[i] - $
                           median_x[i])^2 / (n_elements(valid_index)-1)))
            stddev_y[i] = $
               sqrt(total((data[valid_index].beam_corrected_offset_y[i] - $
                           median_y[i])^2 / (n_elements(valid_index)-1)))
          endelse
        endelse
      endelse
    endif
  endfor

  median_stddev_x = median(stddev_x)
  median_stddev_y = median(stddev_y)
  stddev_stddev_x = sqrt(total((stddev_x - median_stddev_x)^2 / (n_bolos-1)))
  stddev_stddev_y = sqrt(total((stddev_y - median_stddev_y)^2 / (n_bolos-1)))

endwhile
endelse

;--------------------------------------------------------------------------
;
; Now that the "outliers" have been cut, we can print the on-the-sky
; pixel positions to a file.  The file will also include statistical
; information about the beam positions.
;
;--------------------------------------------------------------------------

;medians were used above to allow the iterative cutter to eliminate
;the outliers, but we want to print the mean values of the beam
;positions to the file.
mean_x = fltarr(n_bolos)
mean_y = fltarr(n_bolos)
err_x = fltarr(n_bolos)
err_y = fltarr(n_bolos)
gee = 0
rotangle = 0
for i=0, n_bolos-1 do begin
  valid_index = where(data.mask[i] eq 1)
  ; Allow single points if you are calculating for rotation angle
  If ((n_elements(valid_index) eq 1) and (rotangle ne 0) and (valid_index[0] ne -1)) then begin
      message,'Rotator angle is not 0. and there is only one point for bolometer ' + $
        strtrim(string(fix(data[0].bolo_num[i])),1) + $
        ' therefore will not calculate error for this point and will be set to 0.0', $
        /cont
      message, string(valid_index),/cont
      mean_x[i] = mean(data[valid_index].beam_corrected_offset_x[i])
      mean_y[i] = mean(data[valid_index].beam_corrected_offset_y[i])
      err_x[i] = 0.0
      err_y[i] = 0.0
      gee = gee + 1
  endif else begin
      if(n_elements(valid_index) gt 1) then begin
          mean_x[i] = mean(data[valid_index].beam_corrected_offset_x[i])
          mean_y[i] = mean(data[valid_index].beam_corrected_offset_y[i])
          err_x[i] = sqrt((moment(data[valid_index].beam_corrected_offset_x[i]))[1]) / $
            sqrt(float(n_elements(valid_index)))
          err_y[i] = sqrt((moment(data[valid_index].beam_corrected_offset_y[i]))[1]) / $
            sqrt(float(n_elements(valid_index)))
      endif else begin
          message, 'Not enough valid data points for bolometer ' + $
            strtrim(string(fix(data[0].bolo_num[i])),1) + $
            ' to calculate its mean position and rms.  ' + $
            'To print an output file without this bolometer ' + $
            'run the program again with the bolometer number ' + $
            'added to the bad_bolos keyword.'
      endelse
  endelse
endfor
;now convert the bolometer positions to polar coordinates.
bolo_dist = sqrt(mean_x^2 + mean_y^2)
bolo_ang = atan(mean_y, mean_x) / !dtor
;bolo_ang = fltarr(n_bolos)
;for i=0, n_bolos-1 do begin
;  if(mean_x[i] gt 0) then begin
;    bolo_ang[i] = atan(mean_y[i] / mean_x[i]) / !dtor
;  endif else begin
;    bolo_ang[i] = 180. + atan(mean_y[i] / mean_x[i]) / !dtor
;  endelse
;endfor
bolo_err = sqrt(err_x^2 + err_y^2)

;now print the data to a file
openw, lun, out_file, /get_lun, width = 100
printf, lun, ';BOLOCAM BEAM POSITIONS ON THE SKY'
printf, lun, ';'
printf, lun, ';bolometer    distance      angle     rms/sqrt(n_points)'
for i=0, 143 do begin
index = where(good_bolos eq i)
  if(index gt -1) then begin
    printf, lun, strtrim(string(i),1), $
                 bolo_dist[index], bolo_ang[index], bolo_err[index], $
      format = '("   ",  I3, "       ",  F8.4, "     ", F9.4, "   ", F8.4)'
  endif else begin
    printf, lun, strtrim(string(i),1), $
                 0., 0., 0., $
      format = '("   ",  I3, "       ",  F8.4, "     ", F9.4, "   ", F8.4)'
  endelse    
endfor
close, lun
free_lun, lun

end

